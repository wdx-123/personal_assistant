name: cd-prod

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: prod-deploy
  cancel-in-progress: false

env:
  IMAGE_NAME: ghcr.io/wdx-123/assist-backed
  DEPLOY_DIR: /opt/assist-backed
  DEFAULT_HEALTH_URL: http://127.0.0.1:9000/api/v1/health

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test ./...

      - name: Run vet
        run: go vet ./...

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: v1.64

  build_and_push:
    runs-on: ubuntu-latest
    needs:
      - verify
    outputs:
      image_tag_sha: ${{ steps.meta.outputs.image_tag_sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute image tag
        id: meta
        run: echo "image_tag_sha=sha-${GITHUB_SHA::12}" >> "$GITHUB_OUTPUT"

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push multi-arch image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.image_tag_sha }}
            ${{ env.IMAGE_NAME }}:main
            ${{ env.IMAGE_NAME }}:latest

  deploy_prod:
    runs-on: ubuntu-latest
    needs:
      - build_and_push
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate SSH known hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf "%s\n" "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          if ssh-keygen -F "${{ secrets.SSH_HOST }}" -f ~/.ssh/known_hosts >/dev/null; then
            exit 0
          fi
          ssh-keygen -F "[${{ secrets.SSH_HOST }}]:${{ secrets.SSH_PORT }}" -f ~/.ssh/known_hosts >/dev/null

      - name: Ensure deploy directory exists
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            mkdir -p "${{ env.DEPLOY_DIR }}"
            mkdir -p "${{ env.DEPLOY_DIR }}/static" "${{ env.DEPLOY_DIR }}/log"

      - name: Upload production compose file
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: deploy/docker-compose.prod.yml
          target: ${{ env.DEPLOY_DIR }}
          strip_components: 1

      - name: Deploy and health check
        uses: appleboy/ssh-action@v1.0.3
        env:
          GHCR_PULL_USER: ${{ secrets.GHCR_PULL_USER }}
          GHCR_PULL_TOKEN: ${{ secrets.GHCR_PULL_TOKEN }}
          DEPLOY_HEALTH_URL: ${{ secrets.DEPLOY_HEALTH_URL }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ needs.build_and_push.outputs.image_tag_sha }}
          DEPLOY_DIR: ${{ env.DEPLOY_DIR }}
          DEFAULT_HEALTH_URL: ${{ env.DEFAULT_HEALTH_URL }}
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          envs: GHCR_PULL_USER,GHCR_PULL_TOKEN,DEPLOY_HEALTH_URL,IMAGE_NAME,IMAGE_TAG,DEPLOY_DIR,DEFAULT_HEALTH_URL
          script: |
            set -euo pipefail

            cd "$DEPLOY_DIR"

            if [ ! -f ".env" ]; then
              echo "missing $DEPLOY_DIR/.env"
              exit 1
            fi

            echo "$GHCR_PULL_TOKEN" | docker login ghcr.io -u "$GHCR_PULL_USER" --password-stdin

            printf "IMAGE_NAME=%s\nIMAGE_TAG=%s\n" "$IMAGE_NAME" "$IMAGE_TAG" > .deploy.env

            last_success_tag=""
            if [ -f .last_success_tag ]; then
              last_success_tag="$(cat .last_success_tag)"
            fi

            deploy_failed=0

            docker compose -f docker-compose.prod.yml --env-file .deploy.env pull app || deploy_failed=1
            if [ "$deploy_failed" -eq 0 ]; then
              docker compose -f docker-compose.prod.yml --env-file .deploy.env up -d app || deploy_failed=1
            fi

            health_url="${DEPLOY_HEALTH_URL:-}"
            if [ -z "$health_url" ]; then
              health_url="$DEFAULT_HEALTH_URL"
            fi

            if [ "$deploy_failed" -eq 0 ]; then
              health_ok=0
              for i in $(seq 1 30); do
                if curl -fsS "$health_url" >/dev/null; then
                  health_ok=1
                  break
                fi
                sleep 2
              done

              if [ "$health_ok" -eq 1 ]; then
                echo "$IMAGE_TAG" > .last_success_tag
                echo "deploy success"
                exit 0
              fi
            fi

            echo "deploy failed, start rollback"
            if [ -n "$last_success_tag" ]; then
              printf "IMAGE_NAME=%s\nIMAGE_TAG=%s\n" "$IMAGE_NAME" "$last_success_tag" > .deploy.env
              docker compose -f docker-compose.prod.yml --env-file .deploy.env pull app || true
              docker compose -f docker-compose.prod.yml --env-file .deploy.env up -d app || true
            else
              echo "no rollback target found"
            fi

            exit 1
